{"version":3,"sources":["webpack:///webpack/bootstrap 800dfd69c3025cba81e1","webpack:///./src/app.ts","webpack:///./src/app.css","webpack:///./~/ts-promise/dist/lib/index.js","webpack:///./~/ts-promise/dist/lib/Promise.js","webpack:///./~/ts-promise/dist/lib/async.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/process/browser.js","webpack:///./~/ts-promise/dist/lib/util.js","webpack:///./~/ts-promise/dist/lib/Trace.js","webpack:///./~/ts-promise/dist/lib/Stack.js","webpack:///./~/ts-promise/dist/lib/BaseError.js","webpack:///./~/ts-promise/dist/lib/polyfill.js","webpack:///./src/location-service.ts","webpack:///./src/dto-converter.ts","webpack:///./src/weather-dto.ts"],"names":[],"mappings":"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CA;AACA;AACA,EAAC,sBAAsB;AACvB;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,wCAAuC,EAAE,UAAU,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,uBAAuB,EAAE;AACjE,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,cAAc,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,aAAa,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA,uCAAsC,+BAA+B,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,qBAAqB,uBAAuB,EAAE;AAC/D;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,0EAA0E,EAAE;AAClH,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA,+CAA8C,cAAc;AAC5D;AACA,oC;;;;;;ACj5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,gCAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA,kC;;;;;;;ACzJA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,iBAAiB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,G;;;;;;;AC3EA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACnLtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA,kC;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA,kC;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA,sC;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB;AACA;AACA,4BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA,qC;;;;;;;AC3CA,wCAAoB,CAAY,CAAC;AAEjC;KAAA;KAgDA,CAAC;KA9CG,sCAAY,GAAZ;SACI,IAAI,OAAO,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAChC,CAAC,MAAM,EACP,OAAO,CACV,CAAC;SAEF,IAAI,GAAG,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;aAC1D,MAAM,EAAE,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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 800dfd69c3025cba81e1","import './app.css';\r\nimport Promise from \"ts-promise\";\r\nimport LocationService from \"./location-service\";\r\nimport DtoConverter from \"./dto-converter\";\r\nimport CityWheather from \"./weather-dto\";\r\n\r\nwindow['initMap'] = initMap;\r\n\r\nfunction initMap() {\r\n  let app = new WheatherApp();\r\n\r\n  let locationService = new LocationService();\r\n  let positionPromise = locationService.findLocation();\r\n  positionPromise.then((position: google.maps.LatLng) => {\r\n    app.loadWheather(position);\r\n  });\r\n}\r\n\r\nclass WheatherApp {\r\n\r\n  loadWheather(position: google.maps.LatLng): void {\r\n    const API_ID = '78306410734c69f481aa7b6cc4cd884c'\r\n    let lat = position.lat();\r\n    let lon = position.lng();\r\n    const api = `https://api.openweathermap.org/data/2.5/find/?lat=${lat}&lon=${lon}&APPID=${API_ID}&cnt=5&units=metric`;\r\n    this.getApi(api).then((data: any) => {\r\n      let converter = new DtoConverter(data);\r\n      let cities = converter.parse();\r\n      let myCity: CityWheather = cities[0];\r\n      document.getElementById('my-location').innerHTML = `\r\n        <div>\r\n          <span><b>${myCity.name}: </b></span>\r\n          <img src=\"https://openweathermap.org/img/w/${myCity.icon}.png\">\r\n          <span>${myCity.temperature} °C</span>\r\n        </div>\r\n        <div>\r\n          <span><b>${myCity.main}: </b></span>\r\n          <span>${myCity.description}</span>\r\n        </div>\r\n      `;\r\n\r\n      var iDiv = document.getElementById('city-list');\r\n\r\n      let otherCities = cities.slice(1);\r\n\r\n      otherCities.forEach((city) => {\r\n        var innerDiv = document.createElement('div');\r\n        innerDiv.className = 'city-wheather';\r\n        innerDiv.innerHTML = `\r\n          <div class=\"city-name\">${city.name}</div>\r\n          <div class=\"city-weather\">\r\n            <div class=\"temperature\">\r\n              <div>\r\n                <img src=\"https://openweathermap.org/img/w/${city.icon}.png\">\r\n              </div>\r\n              <div>\r\n                <span>${city.temperature} °C</span>\r\n              </div>\r\n            </div>\r\n            <div class=\"desc\">\r\n                <div>${city.main}:</div>\r\n                <div>${city.description}</div>\r\n            </div>\r\n          </div>\r\n        `;\r\n        iDiv.appendChild(innerDiv);\r\n      });\r\n    });\r\n  }\r\n\r\n  getApi(url: string): Promise<any> {\r\n    return new Promise(function(resolve, reject) {\r\n      window['apiCallback'] = function () {\r\n        resolve(arguments[0]);\r\n      };\r\n\r\n      let script = document.createElement('script');\r\n      script.src = `${url}&callback=apiCallback`;\r\n\r\n      document.head.appendChild(script);\r\n    });\r\n  }\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app.ts","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app.css\n// module id = 1\n// module chunks = 0","/**\n * TS-Promise - fast, robust, type-safe promises\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar Promise_1 = require(\"./Promise\");\nexports.default = Promise_1.default;\nexports.Promise = Promise_1.Promise;\nexports.UnhandledRejectionError = Promise_1.UnhandledRejectionError;\nvar polyfill_1 = require(\"./polyfill\");\nexports.polyfill = polyfill_1.default;\n// Temporary, should be moved to its own package some day\nvar BaseError_1 = require(\"./BaseError\");\nexports.BaseError = BaseError_1.default;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/index.js\n// module id = 5\n// module chunks = 0","/**\n * Promise implementation in TypeScript.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/* tslint:disable:no-unused-expression */ // prevent errors on `trace && trace(....)`\n// TODO:\n// - remove all \"called = true\"-type code in resolvers, replace by single check in _resolve()/_reject()\n// - add possibility for an unhandled-rejections-handler\n// - try to remove mangling of Error's .stack property on rejections with longTraces enabled\nvar async_1 = require(\"./async\");\nvar util_1 = require(\"./util\");\nvar Trace_1 = require(\"./Trace\");\nvar BaseError_1 = require(\"./BaseError\");\n/**\n * Thrown when a rejected promise is explicitly terminated with `.done()`.\n */\nvar UnhandledRejectionError = (function (_super) {\n    __extends(UnhandledRejectionError, _super);\n    function UnhandledRejectionError(reason, trace) {\n        _super.call(this, \"UnhandledRejectionError\", \"unhandled rejection: \" + reason);\n        this.reason = reason;\n        // TODO: Find a better way to merge the location of `.done()` in the\n        // trace, because nobody will look for this property...\n        this.trace = trace;\n        // In case we have a reason, and it has a stack: use it instead of our\n        // own stack, as it's more helpful to see where the original error was\n        // thrown, than where it was thrown inside the promise lib.\n        // In case we don't have a stack, explicitly state so, to not let people\n        // chase a problem in the promise lib that isn't there...\n        var stack = this.reason && typeof this.reason === \"object\" && this.reason.stack;\n        if (typeof stack !== \"string\") {\n            stack = String(reason);\n        }\n        this.stack = \"UnhandledRejectionError: \" + stack;\n    }\n    return UnhandledRejectionError;\n}(BaseError_1.default));\nexports.UnhandledRejectionError = UnhandledRejectionError;\nvar trace = undefined;\nvar longTraces = false;\nvar State;\n(function (State) {\n    State[State[\"Pending\"] = 0] = \"Pending\";\n    State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n    State[State[\"Rejected\"] = 2] = \"Rejected\";\n})(State || (State = {}));\nfunction internalResolver(fulfill, reject) {\n    /* no-op, sentinel value */\n}\ninternalResolver(undefined, undefined); // just for code coverage...\nfunction noop() {\n    /* no-op */\n}\nvar getThenError = {\n    error: undefined,\n};\nfunction wrapNonError(a) {\n    // This is basically a marker for the places where we need to check\n    // handling of errors for .error() support.\n    // A no-op for now.\n    return a;\n}\nvar dummyDoneTrace = new Trace_1.default();\n/**\n * Currently unwrapping promise, while running one of its then-callbacks.\n * Used to set the source of newly created promises.\n * We guarantee that at most one callback of a then() is running at any time.\n */\nvar unwrappingPromise = undefined;\nvar promiseIdCounter = 0;\n/**\n * Fast, robust, type-safe promise implementation.\n */\nvar Promise = (function () {\n    /**\n     * Create new Promise.\n     *\n     * Pass a callback that will receive a `resolve()` and `reject()` function\n     * to seal the promise's fate.\n     *\n     * @param  resolver Called with resolve and reject functions\n     */\n    function Promise(resolver) {\n        var _this = this;\n        this._id = promiseIdCounter++;\n        this._state = 0 /* Pending */;\n        this._result = undefined; // Can be fulfillment value or rejection reason\n        this._handlers = undefined;\n        this._trace = undefined;\n        trace && trace(this, \"construct\");\n        if (longTraces) {\n            this._trace = new Trace_1.default(Promise);\n            if (unwrappingPromise) {\n                this._setSource(unwrappingPromise);\n            }\n        }\n        if (resolver === internalResolver) {\n            // Internally created promises pass 'internalResolver', signalling\n            // that resolving will be done by calling private methods on the\n            // Promise. This saves having to create 2 closures.\n            return;\n        }\n        if (typeof resolver !== \"function\") {\n            throw new TypeError(\"Promise resolver is not a function\");\n        }\n        var called = false;\n        try {\n            resolver(function (y) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,\n                // run `[[Resolve]](promise, y)`\n                called = true;\n                _this._resolve(y);\n            }, function (r) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,\n                // reject `promise` with `r`\n                called = true;\n                _this._reject(wrapNonError(r));\n            });\n        }\n        catch (e) {\n            // 2.3.3.3.4: If calling `then` throws an exception `e`,\n            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.\n            if (!called) {\n                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.\n                called = true;\n                this._reject(wrapNonError(e));\n            }\n        }\n    }\n    /**\n     * Run either `onFulfilled` or `onRejected` callbacks when the promise is\n     * resolved. Returns another promise for the return value of such a\n     * callback.\n     *\n     * The callback will always be called at most once, and always\n     * asynchronously (i.e. some time after e.g. the `resolver` passed to the\n     * constructor has resolved the promise).\n     *\n     * Any error thrown or rejected promise returned from a callback will cause\n     * the returned promise to be rejected with that error.\n     *\n     * If either or both callbacks are missing, the fulfillment or rejection is\n     * passed on unmodified.\n     *\n     * Use `.catch(onRejected)` instead of `.then(undefined, onRejected)` for\n     * stronger typing, better readability, and more functionality (predicates).\n     *\n     * @param onFulfilled Callback called with promise's fulfillment\n     *                    value iff promise is fulfilled. Callback can return\n     *                    another value or promise for a value.\n     * @param onRejected  Optional callback called with promise's rejection\n     *                    reason iff promise is rejected. Callback can return\n     *                    another value or promise for a value.\n     * @return Promise for value returned by either of the callbacks\n     */\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        trace && trace(this, \"then(\" + typeof onFulfilled + \", \" + typeof onRejected + \")\");\n        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== \"function\" ||\n            this._state === 2 /* Rejected */ && typeof onRejected !== \"function\") {\n            // Optimization: handler is short-circuited, so pass the result (value/rejection)\n            // through unmodified.\n            // The typecast is safe, because we either have a fulfillment value\n            // but no handler that could change the type, or a rejection without a\n            // handler that could change it, so R === T in this case.\n            // TODO: verify whether longTraces etc still work as expected\n            return this;\n        }\n        // Construct new Promise, but use subclassed constructor, if any\n        var slave = new (Object.getPrototypeOf(this).constructor)(internalResolver);\n        slave._setSource(this);\n        this._enqueue(onFulfilled, onRejected, slave, undefined);\n        return slave;\n    };\n    /**\n     * Run either `onFulfilled` or `onRejected` callbacks when the promise is\n     * resolved. If the callback throws an error or the returned value resolves\n     * to a rejection, the library will (asynchronously) throw an\n     * `UnhandledRejectionError` with that error.\n     *\n     * The callback will always be called at most once, and always\n     * asynchronously (i.e. some time after e.g. the `resolver` passed to the\n     * constructor has resolved the promise).\n     *\n     * @param onFulfilled Optional callback called with promise's fulfillment\n     *                    value iff promise is fulfilled. Any error thrown or\n     *                    rejection returned will cause an UnhandledRejectionError\n     *                    to be thrown.\n     * @param onRejected  Optional callback called with promise's rejection\n     *                    reason iff promise is rejected. Any error thrown or\n     *                    rejection returned will cause an UnhandledRejectionError\n     *                    to be thrown.\n     */\n    Promise.prototype.done = function (onFulfilled, onRejected) {\n        trace && trace(this, \"done(\" + typeof onFulfilled + \", \" + typeof onRejected + \")\");\n        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== \"function\") {\n            return;\n        }\n        var doneTrace = dummyDoneTrace;\n        if (longTraces) {\n            doneTrace = new Trace_1.default();\n            if (this._trace) {\n                doneTrace.setSource(this._trace);\n            }\n        }\n        this._enqueue(onFulfilled, onRejected, undefined, doneTrace);\n    };\n    /**\n     * Catch only errors that match predicate in case promise is rejected.\n     * Predicate can be an Error (sub-)class, array of Error classes, or a\n     * function that can return true to indicate a match.\n     *\n     * The returned promise is resolved with the output of the callback, so it\n     * is possible to re-throw the error, but also to return a 'replacement'\n     * value that should be used instead.\n     *\n     * @param predicate   Optional Error class, array of Error classes or match\n     *                    function\n     * @param onRejected  Callback called with promise's rejection reason iff\n     *                    promise is rejected. Callback can return another value\n     *                    or promise for a value.\n     * @return Promise for original value, or 'replaced' value in case of error\n     */\n    Promise.prototype.catch = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        if (arguments.length === 1) {\n            var onRejected = arguments[0];\n            return this.then(undefined, onRejected);\n        }\n        else {\n            var predicate_1 = arguments[0];\n            var onRejected_1 = arguments[1];\n            return this.then(undefined, function (reason) {\n                var match = false;\n                if (typeof predicate_1 === \"function\") {\n                    if (predicate_1.prototype instanceof Error || predicate_1 === Error) {\n                        match = reason instanceof predicate_1;\n                    }\n                    else {\n                        match = predicate_1(reason);\n                    }\n                }\n                else if (Array.isArray(predicate_1)) {\n                    for (var i = 0; i < predicate_1.length; i++) {\n                        if (reason instanceof predicate_1[i]) {\n                            match = true;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    throw new TypeError(\"invalid predicate to .catch(), got \" + typeof predicate_1);\n                }\n                if (match) {\n                    return onRejected_1(reason);\n                }\n                return Promise.reject(reason);\n            });\n        }\n    };\n    /**\n     * Asynchronous equivalent of try { } finally { }.\n     *\n     * Runs `handler` when promise resolves (fulfilled or rejected).\n     * Handler is passed the current promise (which is guaranteed to be\n     * resolved), and can be interrogated with e.g. `isFulfilled()`, `.value()`,\n     * etc.\n     *\n     * When `handler` returns `undefined` or its promise is fulfilled, the\n     * promise from `finally()` is resolved to the original promise's resolved\n     * value or rejection reason.\n     * If `handler` throws an error or returns a rejection, the result of\n     * `finally()` will be rejected with that error.\n     *\n     * Example:\n     * someLenghtyOperation().finally((result) => {\n     *   if (result.isFulfilled()) {\n     *     console.log(\"succeeded\");\n     *   } else {\n     *     console.log(\"failed\", result.reason());\n     *   }\n     * });\n     *\n     * @param  handler [description]\n     * @return promise with same value/reason as this one, after `handler`'s\n     *         result (if any) has been fulfilled, or a promise rejected with\n     *         `handler`'s error if it threw one or returned a rejection.\n     */\n    Promise.prototype.finally = function (handler) {\n        var _this = this;\n        var runner = function () { return handler(_this); };\n        return this.then(runner, runner).return(this);\n    };\n    /**\n     * @return `true` when promise is fulfilled, `false` otherwise.\n     */\n    Promise.prototype.isFulfilled = function () {\n        return this._state === 1 /* Fulfilled */;\n    };\n    /**\n     * @return `true` when promise is rejected, `false` otherwise.\n     */\n    Promise.prototype.isRejected = function () {\n        return this._state === 2 /* Rejected */;\n    };\n    /**\n     * @return `true` when promise is pending (may be resolved to another pending\n     *         promise), `false` otherwise.\n     */\n    Promise.prototype.isPending = function () {\n        return this._state === 0 /* Pending */;\n    };\n    /**\n     * @return Fulfillment value if fulfilled, otherwise throws an error.\n     */\n    Promise.prototype.value = function () {\n        if (!this.isFulfilled()) {\n            throw new Error(\"Promise is not fulfilled\");\n        }\n        return this._result;\n    };\n    /**\n     * @return Rejection reason if rejected, otherwise throws an error.\n     */\n    Promise.prototype.reason = function () {\n        if (!this.isRejected()) {\n            throw new Error(\"Promise is not rejected\");\n        }\n        return this._result;\n    };\n    /**\n     * @return A human-readable representation of the promise and its status.\n     */\n    Promise.prototype.inspect = function () {\n        return this.toString();\n    };\n    /**\n     * @return A human-readable representation of the promise and its status.\n     */\n    Promise.prototype.toString = function () {\n        var state;\n        switch (this._state) {\n            case 0 /* Pending */:\n                state = \"pending\";\n                break;\n            case 1 /* Fulfilled */:\n                state = \"fulfilled\";\n                break;\n            case 2 /* Rejected */:\n                state = \"rejected\";\n                break;\n            /* istanbul ignore next */\n            default: state = \"unknown\";\n        }\n        return \"[Promise \" + this._id + \": \" + state + \"]\";\n    };\n    /**\n     * Create a promise that resolves with the same value of this promise, after\n     * `ms` milliseconds. The timer will start when the current promise is\n     * resolved.\n     * If the current promise is rejected, the resulting promise is also\n     * rejected, without waiting for the timer.\n     *\n     * @param ms Number of milliseconds to wait before resolving\n     * @return Promise that fulfills `ms` milliseconds after this promise fulfills\n     */\n    Promise.prototype.delay = function (ms) {\n        return this.then(function (value) {\n            return new Promise(function (resolve) {\n                setTimeout(function () { return resolve(value); }, ms);\n            });\n        });\n    };\n    /**\n     * Return a promise that resolves to `value` after this promise is\n     * fulfilled.\n     * Returned promise is rejected if this promise is rejected.\n     *\n     * Equivalent to `.then(() => value)`.\n     *\n     * @param value Value or promise for value of returned promise\n     * @return Promise resolved to value after this promise fulfills\n     */\n    Promise.prototype.return = function (value) {\n        if (value === undefined) {\n            // In TypeScript, we often need to 'force' a promise to become a\n            // void promise, so this is a common case. Prevents the closure.\n            // (Note: the any cast is just because TS assumes were going to\n            // return an R, but we're in fact going to return a void.)\n            return this.then(noop);\n        }\n        return this.then(function () { return value; });\n    };\n    /**\n     * Return a promise that is rejected with `reason` after this promise is\n     * fulfilled.\n     * If this promise is rejected, returned promise will rejected with that\n     * error instead.\n     *\n     * Equivalent to `.then(() => { throw value; })`.\n     *\n     * @param reason Error reason to reject returned promise with\n     * @return Promise rejected with `reason` after this promise fulfills\n     */\n    Promise.prototype.throw = function (reason) {\n        return this.then(function () { return Promise.reject(reason); });\n    };\n    /**\n     * Create an immediately resolved promise (in case of a 'normal' value), or\n     * a promise that 'follows' another `Thenable` (e.g. a Promise from another\n     * library).\n     *\n     * @param value Value (or Thenable for value) for returned promise\n     * @return Promise resolved to `value`\n     */\n    Promise.resolve = function (value) {\n        var p = new Promise(internalResolver);\n        p._resolve(value);\n        return p;\n    };\n    /**\n     * Create an immediately rejected promise.\n     *\n     * Note: to create a rejected promise of a certain type, use e.g.\n     * `Promise.reject<number>(myError)`\n     *\n     * @param reason Error object to set rejection reason\n     * @return Promise resolved to rejection `reason`\n     */\n    Promise.reject = function (reason) {\n        var p = new Promise(internalResolver);\n        p._reject(reason);\n        return p;\n    };\n    /**\n     * Return a promise for an array of all resolved input promises (or values).\n     * If any of the input promises is rejected, the returned promise is\n     * rejected with that reason.\n     * When passing an empty array, the promises is immediately resolved to an\n     * empty array.\n     *\n     * @param thenables Array of values or promises for them\n     * @return promise that resolves with array of all resolved values\n     */\n    Promise.all = function (thenables) {\n        return new Promise(function (resolve, reject) {\n            util_1.assert(Array.isArray(thenables), \"thenables must be an Array\");\n            if (thenables.length === 0) {\n                resolve([]);\n                return;\n            }\n            var result = new Array(thenables.length);\n            var remaining = thenables.length;\n            for (var i = 0; i < thenables.length; i++) {\n                follow(thenables[i], i);\n            }\n            function follow(t, index) {\n                var slave = t instanceof Promise ? t : Promise.resolve(t);\n                slave.done(function (v) {\n                    result[index] = v;\n                    remaining--;\n                    if (remaining === 0) {\n                        resolve(result);\n                    }\n                }, function (reason) { return reject(reason); });\n            }\n        });\n    };\n    /**\n     * Return a promise that resolves to the fulfillment or rejection of the\n     * first input promise that resolves.\n     * When passing an empty array, the promise will never resolve.\n     *\n     * @param thenables Array of values or promises for them\n     * @return promise that resolves to first resolved input promise\n     */\n    Promise.race = function (thenables) {\n        return new Promise(function (resolve, reject) {\n            util_1.assert(Array.isArray(thenables), \"thenables must be an Array\");\n            for (var i = 0; i < thenables.length; i++) {\n                var t = thenables[i];\n                var slave = t instanceof Promise ? t : Promise.resolve(t);\n                Promise.resolve(slave).done(resolve, reject);\n            }\n        });\n    };\n    /**\n     * Create tuple of a promise and its resolve and reject functions.\n     *\n     * It is generally better (and slightly faster) to use the Promise\n     * constructor to create a promise, as that will also catch any exception\n     * thrown while running the resolver.\n     *\n     * A Deferred can be useful in some scenarios though, e.g. when working with\n     * timers, protocol request/response pairs, etc.\n     *\n     * @return Deferred object, containing unresolved promise and its\n     *         resolve/reject functions\n     */\n    Promise.defer = function () {\n        var resolve;\n        var reject;\n        var p = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        return {\n            promise: p,\n            reject: reject,\n            resolve: resolve,\n        };\n    };\n    /**\n     * Create a promise that resolves to the given value (or promise for a\n     * value) after `ms` milliseconds. The timer will start when the given value\n     * is resolved.\n     * If the input value is a rejected promise, the resulting promise is also\n     * rejected, without waiting for the timer.\n     *\n     * @param value Value or promise for value to be delayed\n     * @param ms Number of milliseconds to wait before resolving\n     * @return Promise that fulfills `ms` milliseconds after given (promise for)\n     *         value is fulfilled\n     */\n    Promise.delay = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        if (arguments[1] === undefined) {\n            // delay(ms)\n            var ms_1 = arguments[0];\n            return new Promise(function (resolve) {\n                setTimeout(resolve, ms_1);\n            });\n        }\n        // delay(value, ms)\n        return Promise.resolve(arguments[0]).delay(arguments[1]);\n    };\n    /**\n     * Enable or disable long stack trace tracking on promises.\n     *\n     * This allows tracing a promise chain through the various asynchronous\n     * actions in a program. For example, when a promise is rejected, the last\n     * few locations of any preceding promises are included in the error's stack\n     * trace.\n     *\n     * Note: it is possible to enable/disable long tracing at runtime.\n     *\n     * When chaining off of a promise that was created while tracing was enabled\n     * (e.g. through `.then()`), all children will also have long traces, even\n     * when tracing is turned off. This allows to trace just some promise paths.\n     *\n     * Tracing is disabled by default as it incurs a memory and performance\n     * overhead, although it's still faster with tracing than some major\n     * promise libraries without tracing, so don't worry too much about it.\n     *\n     * @param enable Set to true to enable long traces, false to disable\n     */\n    Promise.setLongTraces = function (enable) {\n        longTraces = enable;\n    };\n    /**\n     * Set trace function that is called for internal state changes of a\n     * promise.\n     * Call with `undefined` or `null` to disable such tracing (this is the\n     * default).\n     *\n     * @param tracer Callback called for various stages during lifetime of a promise\n     */\n    Promise.setTracer = function (tracer) {\n        if (typeof tracer === \"function\") {\n            trace = tracer;\n        }\n        else {\n            trace = undefined;\n        }\n    };\n    /**\n     * Recursively flush the async callback queue until all `.then()` and\n     * `.done()` callbacks for fulfilled and rejected Promises have been called.\n     * Useful in e.g. unit tests to advance program state to the next 'tick'.\n     *\n     * Note that if e.g. `.done()` encounters a rejected promise, `flush()` will\n     * immediately throw an error (e.g. `UnhandledRejectionError`).\n     * It is safe to call `flush()` again afterwards, but it will also be called\n     * automatically by the async queue on the next 'real' tick.\n     *\n     * It is an error to call `flush()` while it is already running (e.g. from\n     * a `.then()` callback).\n     */\n    Promise.flush = function () {\n        async_1.default.flush();\n    };\n    Promise.prototype._setSource = function (source) {\n        if (!this._trace || !source._trace) {\n            return;\n        }\n        this._trace.setSource(source._trace);\n    };\n    Promise.prototype._resolve = function (x) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        if (!x) {\n            // Shortcut for falsy values, most notably void-Promises\n            // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`\n            this._fulfill(x);\n            return;\n        }\n        // 2.3.1: If promise and x refer to the same object, reject promise with a TypeError as the reason.\n        if (this === x) {\n            this._reject(new TypeError(\"cannot resolve Promise to self\"));\n            return;\n        }\n        // 2.3.2: If `x` is a promise, adopt its state\n        if (x instanceof Promise) {\n            x._setSource(this);\n            if (x._state === 0 /* Pending */) {\n                // 2.3.2.1: If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.\n                this._followPromise(x);\n            }\n            else if (x._state === 1 /* Fulfilled */) {\n                // 2.3.2.2: If/when `x` is fulfilled, fulfill `promise` with the same value.\n                this._fulfill(x._result);\n            }\n            else {\n                // 2.3.2.3: If/when `x` is rejected, reject `promise` with the same reason.\n                this._reject(x._result);\n            }\n            return;\n        }\n        // 2.3.3: Otherwise, if `x` is an object or function,\n        if (typeof x === \"object\" || typeof x === \"function\") {\n            // 2.3.3.1: Let `then` be `x.then`\n            var then = this._tryGetThen(x);\n            // 2.3.3.2: If retrieving the property `x.then` results in a thrown\n            // exception `e`, reject `promise` with `e` as the reason.\n            if (then === getThenError) {\n                this._reject(wrapNonError(getThenError.error));\n                return;\n            }\n            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,\n            //          first argument `resolvePromise`, and second argument `rejectPromise`\n            if (typeof then === \"function\") {\n                this._followThenable(x, then);\n                return;\n            }\n        }\n        // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`\n        this._fulfill(x);\n    };\n    Promise.prototype._tryGetThen = function (x) {\n        try {\n            // 2.3.3.1: Let `then` be `x.then`\n            var then = x.then;\n            return then;\n        }\n        catch (e) {\n            // 2.3.3.2: If retrieving the property `x.then` results in a thrown\n            // exception `e`, reject `promise` with `e` as the reason.\n            getThenError.error = e;\n            return getThenError;\n        }\n    };\n    Promise.prototype._fulfill = function (value) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_fulfill(\" + typeof value + \")\");\n        // 2.1.2.2 When fulfilled, a promise must have a value, which must not change.\n        this._state = 1 /* Fulfilled */;\n        this._result = value;\n        this._flush();\n    };\n    Promise.prototype._reject = function (reason) {\n        var _this = this;\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_reject(\" + reason + \")\");\n        // 2.1.3.2 When rejected, a promise must have a reason, which must not change.\n        this._state = 2 /* Rejected */;\n        this._result = reason;\n        if (this._trace && this._result instanceof Error && !this._result.trace) {\n            this._result.trace = this._trace;\n            // TODO: Meh, this always accesses '.stack', which is supposed to be expensive\n            var originalStack = this._result.stack;\n            // Stack may be undefined if e.g. a Stack Overflow occurred\n            if (originalStack) {\n                Object.defineProperty(this._result, \"stack\", {\n                    enumerable: false,\n                    get: function () { return originalStack + \"\\n  from Promise at:\\n\" + _this._trace.inspect(); },\n                });\n            }\n        }\n        this._flush();\n    };\n    Promise.prototype._followPromise = function (slave) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_follow([Promise \" + slave._id + \"])\");\n        slave._enqueue(undefined, undefined, this, undefined);\n    };\n    Promise.prototype._followThenable = function (slave, then) {\n        var _this = this;\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_follow([Thenable])\");\n        var called = false;\n        try {\n            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,\n            //          first argument `resolvePromise`, and second argument `rejectPromise`\n            then.call(slave, function (y) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,\n                // run `[[Resolve]](promise, y)`\n                called = true;\n                _this._resolve(y);\n            }, function (r) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,\n                // reject `promise` with `r`\n                called = true;\n                _this._reject(wrapNonError(r));\n            });\n        }\n        catch (e) {\n            // 2.3.3.3.4: If calling `then` throws an exception `e`,\n            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.\n            if (!called) {\n                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.\n                called = true;\n                this._reject(wrapNonError(e));\n            }\n        }\n    };\n    Promise.prototype._enqueue = function (onFulfilled, onRejected, slave, done) {\n        var h = {\n            promise: this,\n            onFulfilled: onFulfilled,\n            onRejected: onRejected,\n            slave: slave,\n            done: done,\n        };\n        if (this._state !== 0 /* Pending */) {\n            async_1.default.enqueue(Promise._unwrapper, h);\n        }\n        else {\n            if (!this._handlers) {\n                this._handlers = [h];\n            }\n            else {\n                var i = this._handlers.length;\n                this._handlers[i] = h;\n            }\n        }\n    };\n    /**\n     * Schedule any pending .then()/.done() callbacks and follower-promises to\n     * be called/resolved.\n     * Clears our queue, any callbacks/followers attached after this will be\n     * scheduled without going through our handlers queue.\n     */\n    Promise.prototype._flush = function () {\n        if (!this._handlers) {\n            return;\n        }\n        var i = 0;\n        var h = this._handlers;\n        var l = h.length;\n        this._handlers = undefined;\n        while (i < l) {\n            // Note: we enqueue every single callback/follower separately,\n            // because e.g. .done() might throw and we need to ensure we can\n            // continue after that. async handles that for us.\n            // And because the queue needs to be processed in-order, we can't\n            // 'filter' the non-callback operations out either.\n            async_1.default.enqueue(Promise._unwrapper, h[i++]);\n        }\n    };\n    /**\n     * 'Unwrap' a promise handler, i.e. call a .then()/.done() callback, or\n     * resolve a promise that's following us.\n     * @param handler The handler being processed\n     */\n    Promise.prototype._unwrap = function (handler) {\n        var callback = this._state === 1 /* Fulfilled */ ? handler.onFulfilled : handler.onRejected;\n        if (handler.done) {\n            // Unwrap .done() callbacks\n            trace && trace(this, \"_unwrap()\");\n            if (typeof callback !== \"function\") {\n                // No callback: if we ended in a rejection, throw it, otherwise\n                // all was good.\n                if (this._state === 2 /* Rejected */) {\n                    var unhandled = new UnhandledRejectionError(this._result, handler.done);\n                    // TODO Allow intercepting these\n                    // Leave the comment after the throw: may show up in source line in node\n                    throw unhandled; // Unhandled exception caught by .done()\n                }\n                return;\n            }\n            util_1.assert(!unwrappingPromise);\n            unwrappingPromise = this;\n            try {\n                var result = callback(this._result);\n                if (result) {\n                    // May be a thenable, need to start following it...\n                    var p = (result instanceof Promise) ? result : Promise.resolve(result);\n                    p.done(); // Ensure it throws as soon as it's rejected\n                }\n                unwrappingPromise = undefined;\n            }\n            catch (e) {\n                unwrappingPromise = undefined;\n                // Wrap in UnhandledRejectionError\n                var unhandled = new UnhandledRejectionError(e, handler.done);\n                // TODO Allow intercepting these\n                // Leave the comment after the throw: may show up in source line in node\n                throw unhandled; // Unhandled exception caught by .done()\n            }\n            return;\n        }\n        // Unwrap .then() callbacks, or resolve 'parent' promise\n        //\n        // Three scenarios are handled here:\n        // 1. An onFulfilled callback was registered and promise is fulfilled,\n        //    or onRejected callback was registered and promise is rejected\n        //    -> callback is a function, slave is the promise that was returned\n        //       from the .then() call, so resolve slave with outcome of callback\n        // 2. An onFulfilled callback was registered but promise is rejected,\n        //    or onRejected callback was registered but promise is fulfilled\n        //    -> callback is not a function (typically `undefined`), slave is\n        //       promise that was returned from the .then() call, so resolve it\n        //       with our own result (thereby 'skipping' the .then())\n        // 3. Another promise attached itself on our 'callback queue' to be\n        //    resolved when we do (i.e. its fate is determined by us)\n        //    -> callbacks will both be undefined, slave is that other promise\n        //       that wants to be resolved with our result\n        var slave = handler.slave;\n        trace && trace(this, \"_unwrap(\" + slave._id + \")\");\n        if (typeof callback === \"function\") {\n            // Case 1\n            util_1.assert(!unwrappingPromise);\n            unwrappingPromise = slave;\n            try {\n                // 2.2.5 handlers must be called as functions\n                slave._resolve(callback(this._result));\n            }\n            catch (e) {\n                slave._reject(wrapNonError(e));\n            }\n            unwrappingPromise = undefined;\n        }\n        else {\n            // Case 2 and 3\n            if (this._state === 1 /* Fulfilled */) {\n                slave._fulfill(this._result);\n            }\n            else {\n                slave._reject(this._result);\n            }\n        }\n    };\n    /**\n     * Helper for unwrapping promise handler.\n     * It's not a closure so it's cheap to schedule, and because it directly\n     * calls the _unwrap() method on a promise, it's (way) faster than having to\n     * use e.g. .call().\n     * @param handler The handler being processed\n     */\n    Promise._unwrapper = function (handler) {\n        handler.promise._unwrap(handler);\n    };\n    return Promise;\n}());\nexports.Promise = Promise;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Promise;\n//# sourceMappingURL=Promise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/Promise.js\n// module id = 6\n// module chunks = 0","/**\n * Call queue for executing callbacks asynchronously.\n *\n * Prevents releasing Zalgo.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n// TODO:\n// - simpler code\nvar util_1 = require(\"./util\");\nvar CallQueue = (function () {\n    function CallQueue() {\n        this.length = 0;\n        // Basically twice the number of simultaneously resolving promises\n        this._max = 1000;\n        this._first = 0;\n    }\n    /**\n     * Push a new callback to the queue.\n     * @return true when the queue still has space, false if it's now 'full'\n     */\n    CallQueue.prototype.push = function (callback, arg) {\n        this[this.length++] = callback;\n        this[this.length++] = arg;\n        return this.length < this._max;\n    };\n    /**\n     * Flush all callbacks in this queue.\n     * Note that it is 'ok' for callbacks to throw an error;\n     * the next call to flush() will flush the remainder of the queue.\n     * When this function returns, the queue will be 'reset' to its beginning.\n     */\n    CallQueue.prototype.flush = function () {\n        while (this._first < this.length) {\n            var callback = this[this._first];\n            var arg = this[this._first + 1];\n            this[this._first] = this[this._first + 1] = undefined;\n            this._first += 2;\n            callback(arg);\n        }\n        this.length = 0;\n        this._first = 0;\n    };\n    return CallQueue;\n}());\nvar Async = (function () {\n    function Async() {\n        var _this = this;\n        /* tslint:disable:member-ordering */ // trips on the arrow-function, thinks it's something public\n        this._pool = [];\n        this._ring = [new CallQueue()];\n        this._current = this._ring[0];\n        this._flusher = function () { return _this._scheduledFlush(); };\n        this._flushing = false;\n        this._scheduled = false;\n        this._scheduler = undefined;\n    }\n    /* tslint:enable:member-ordering */\n    /**\n     * Configure alternative scheduler to use.\n     * The scheduler function will be called with a flusher, which needs to be\n     * executed to flush the queue. Note: the flusher may throw an\n     * exception, if any of the callbacks on the queue throws one.\n     * This will result in another flush to be scheduled before returning.\n     *\n     * Call with `undefined` to reset the scheduler to the default (setImmediate).\n     *\n     * Example usage (this is basically the default):\n     *   setScheduler((flusher) => setImmediate(flusher));\n     */\n    Async.prototype.setScheduler = function (scheduler) {\n        /* tslint:disable:no-null-keyword */ // 'old' API told you to use `null` instead of `undefined`\n        util_1.assert(scheduler === undefined || scheduler === null || typeof scheduler === \"function\");\n        /* tslint:enable:no-null-keyword */\n        this._scheduler = scheduler;\n    };\n    Async.prototype.enqueue = function (callback, arg) {\n        if (!this._flushing && !this._scheduled) {\n            this._schedule();\n        }\n        if (!this._current) {\n            this._current = this._pool.pop();\n            if (!this._current) {\n                this._current = new CallQueue();\n            }\n            this._ring.push(this._current);\n        }\n        if (!this._current.push(callback, arg)) {\n            this._current = undefined;\n        }\n    };\n    Async.prototype.flush = function () {\n        util_1.assert(!this._flushing, \"cannot recursively flush\");\n        this._flushing = true;\n        try {\n            while (true) {\n                // Note: ring is guaranteed to have at least one queue (even though\n                // queue might be empty when flush() is e.g. called manually).\n                this._ring[0].flush();\n                // ring[0] is now guaranteed to be empty, so we could move it to\n                // the pool.\n                // However, if it's the last item remaining, better to simply\n                // leave it in the ring, saves unnecessary re-move on next\n                // enqueue.\n                if (this._ring.length === 1) {\n                    // First queue is now empty, so we can re-use it again (if\n                    // it was full last time)\n                    this._current = this._ring[0];\n                    break;\n                }\n                util_1.assert(this._current !== this._ring[0]);\n                this._pool.push(this._ring.shift());\n            }\n        }\n        finally {\n            this._flushing = false;\n            // If one of the callbacks in the queue throws an exception,\n            // (e.g. when Promise#done() detects a rejection) make sure to\n            // reschedule the remainder of the queue(s) for another iteration.\n            // This approach has the advantage of immediately allowing to stop\n            // the program in e.g. NodeJS, but also allows to continue running\n            // correctly in a browser.\n            if (this._ring[0].length > 0 && !this._scheduled) {\n                this._schedule();\n            }\n        }\n    };\n    Async.prototype._schedule = function () {\n        util_1.assert(!this._scheduled);\n        // Note: we 'fall back' to setImmediate here (instead of e.g.\n        // assigning it to the _scheduler property once), to allow\n        // setImmediate to be e.g. replaced by a mocked one (e.g. Sinon's\n        // useFakeTimers())\n        var scheduler = this._scheduler;\n        if (!scheduler) {\n            scheduler = typeof setImmediate === \"function\" ? setImmediate : setTimeout;\n        }\n        scheduler(this._flusher);\n        this._scheduled = true;\n    };\n    Async.prototype._scheduledFlush = function () {\n        // Indicate that this 'iteration' of the flush is complete.\n        this._scheduled = false;\n        this.flush();\n    };\n    return Async;\n}());\nexports.Async = Async;\nexports.async = new Async();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports.async;\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/async.js\n// module id = 7\n// module chunks = 0","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 8\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 9\n// module chunks = 0","/**\n * Helper utilities.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n/**\n * Throw an Error when given condition is false.\n *\n * @param {any}    condition Condition, no-op when truthy, error thrown when falsy\n * @param {string} msg       Optional text to include in error message\n */\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg ? \"assertion failed: \" + msg : \"assertion failed\");\n    }\n}\nexports.assert = assert;\n/**\n * Return reference to the global object (if possible).\n *\n * @return {any} Reference to the global object (e.g. `window`, `global`, etc.),\n *               or `undefined` if it could not be determined.\n */\nfunction getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    // Otherwise, try to use `this`.\n    // We use eval-like behavior, because it will not inherit our \"use strict\",\n    // see http://stackoverflow.com/questions/3277182/how-to-get-the-global-object-in-javascript\n    var g;\n    try {\n        g = new Function(\"return this\")();\n    }\n    catch (e) {\n    }\n    return g;\n}\nexports.getGlobal = getGlobal;\n//# sourceMappingURL=util.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/util.js\n// module id = 10\n// module chunks = 0","/**\n * Helper class for capturing stack traces.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n// TODO:\n// - test/make it work in non-V8\nvar Stack_1 = require(\"./Stack\");\n/**\n * Stack trace container with optional source traces.\n *\n * Typically used for capturing traces across asynchronous calls (e.g.\n * with Promises or Events).\n */\nvar Trace = (function () {\n    function Trace(ignoreUntil) {\n        if (ignoreUntil === void 0) { ignoreUntil = Trace; }\n        this.stack = new Stack_1.default(ignoreUntil);\n    }\n    /**\n     * Assign another Trace as the source of this Trace.\n     *\n     * Note: the stack of `source` is copied to this Trace, in order to allow\n     * truncating the trace length to `Trace.traceLimit` to prevent memory\n     * exhaustion on e.g. recursive traces.\n     *\n     * @param source Trace to use as source.\n     */\n    Trace.prototype.setSource = function (source) {\n        if (!source.sources) {\n            this.sources = [source.stack];\n        }\n        else {\n            this.sources = source.sources.concat(source.stack);\n            if (this.sources.length > Trace.traceLimit) {\n                this.sources = this.sources.slice(0, Trace.traceLimit);\n            }\n        }\n    };\n    Trace.prototype.inspect = function () {\n        var result = this.stack.inspect();\n        if (this.sources) {\n            for (var i = this.sources.length - 1; i >= 0; i--) {\n                result += \"\\n  from previous:\\n\" + this.sources[i].inspect();\n            }\n        }\n        return result;\n    };\n    Trace.traceLimit = 10;\n    return Trace;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Trace;\n//# sourceMappingURL=Trace.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/Trace.js\n// module id = 11\n// module chunks = 0","/**\n * Helper class for capturing stack traces.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n// TODO:\n// - test/make it work in non-V8\n// - parse stacks into platform-independent object-arrays\nvar hasStacks = (typeof Error.captureStackTrace === \"function\");\nvar Stack = (function () {\n    function Stack(ignoreUntil) {\n        if (ignoreUntil === void 0) { ignoreUntil = Stack; }\n        /* istanbul ignore else */ // TODO: remove when testing for non-V8\n        if (hasStacks) {\n            Error.captureStackTrace(this, ignoreUntil);\n        }\n        else {\n            this.stack = \"dummy\\n<no trace>\";\n        }\n    }\n    Stack.prototype.inspect = function () {\n        var lines = this.stack.split(\"\\n\");\n        lines.shift(); // Strip the \"[object Object]\" line\n        return lines.join(\"\\n\");\n    };\n    return Stack;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Stack;\n//# sourceMappingURL=Stack.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/Stack.js\n// module id = 12\n// module chunks = 0","/**\n * Base class for custom errors.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar hasStacks = (typeof Error.captureStackTrace === \"function\");\nvar BaseError = (function (_super) {\n    __extends(BaseError, _super);\n    function BaseError(name, message) {\n        _super.call(this, message);\n        this.name = name;\n        // Note: still need to 'manually' assign .message,\n        // because engines apparently don't allow subclassing properly.\n        // https://github.com/Microsoft/TypeScript/issues/1168#issuecomment-107729088\n        this.message = message;\n        /* istanbul ignore else */ // TODO: remove when testing for non-V8\n        if (hasStacks) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        else {\n            this.stack = \"dummy\\n<no trace>\";\n        }\n    }\n    return BaseError;\n}(Error));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BaseError;\n//# sourceMappingURL=BaseError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/BaseError.js\n// module id = 13\n// module chunks = 0","/**\n * Polyfill implementation.\n *\n * Copyright (C) 2016 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar Promise_1 = require(\"./Promise\");\nvar util_1 = require(\"./util\");\n/**\n * Polyfill global `Promise` instance with ts-promise version.\n * By default, it will only install a ts-promise version if no other\n * implementation is present. Use `force = true` to unconditionally replace the\n * promise implementation.\n *\n * Warning: in general, it's not really recommended to use polyfills, because\n * other libraries may e.g. use the fact that certain platform features are\n * absent to create a 'fingerprint' of a platform, and it may conflict with\n * other libraries that are trying to do the same thing.\n * If you're writing your own library, it's much better to simply directly\n * require/import ts-promise, and use its class directly.\n * However, if you're the 'end-user' (i.e. application, not a library), it may\n * be a viable solution to make Promises available on platforms that otherwise\n * don't have them.\n *\n * @param  {boolean}  force (Optional, default false) Forcibly overwrite existing Promise implementation with ts-promise version.\n * @return {boolean}        Returns true when global Promise is (now) a ts-promise (or derived class), false otherwise.\n */\nfunction polyfill(force) {\n    if (force === void 0) { force = false; }\n    // Get reference to globals (`global`, `window`, etc.)\n    var global = util_1.getGlobal();\n    if (!global) {\n        return false;\n    }\n    if (force || typeof global.Promise !== \"function\") {\n        global.Promise = Promise_1.Promise;\n        return true;\n    }\n    return global.Promise instanceof Promise_1.Promise;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = polyfill;\n//# sourceMappingURL=polyfill.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/polyfill.js\n// module id = 14\n// module chunks = 0","import Promise from \"ts-promise\";\r\n\r\nexport default class LocationService {\r\n\r\n    findLocation(): Promise<google.maps.LatLng> {\r\n        let current = new google.maps.LatLng(\r\n            -34.397,\r\n            150.644\r\n        );\r\n\r\n        let map = new google.maps.Map(document.getElementById('map'), {\r\n            center: current,\r\n            zoom: 10\r\n        });\r\n\r\n        let infoWindow = new google.maps.InfoWindow(map);\r\n\r\n        return new Promise<google.maps.LatLng>(function(resolve, reject) {\r\n            // Try HTML5 geolocation.\r\n            if (navigator.geolocation) {\r\n                navigator.geolocation.getCurrentPosition(function (position) {\r\n                    let coords = position.coords;\r\n                    current = new google.maps.LatLng(\r\n                        coords.latitude,\r\n                        coords.longitude\r\n                    );\r\n\r\n                    infoWindow.setPosition(current);\r\n                    infoWindow.setContent('Location found.');\r\n                    map.setCenter(current);\r\n                    resolve(current)\r\n                }, function () {\r\n                    this.handleLocationError(true, infoWindow, map.getCenter());\r\n                    reject(null);\r\n                });\r\n            } else {\r\n                // Browser doesn't support Geolocation\r\n                this.handleLocationError(false, infoWindow, map.getCenter());\r\n                reject(null);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    handleLocationError(browserSupport:boolean, infoWindow:google.maps.InfoWindow, pos:google.maps.LatLng) {\r\n        infoWindow.setPosition(pos);\r\n        infoWindow.setContent(browserSupport ?\r\n            'Error: The Geolocation service failed.' :\r\n            'Error: Your browser doesn\\'t support geolocation.');\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/location-service.ts","import CityWheather from \"./weather-dto\";\r\n\r\nexport default class DtoConverter {\r\n\r\n  constructor(private _data: string) { }\r\n\r\n  parse(): CityWheather[] {\r\n    let cities = this._data['list'];\r\n    let wheather = cities.map((city: CityDto) => this.parseCity(city));\r\n\r\n    return wheather;\r\n  }\r\n\r\n  private parseCity(dto: CityDto) : CityWheather {\r\n    let city = new CityWheather();\r\n    city.name = dto.name;\r\n    city.temperature = dto.main.temp;\r\n    city.main = dto.weather[0].main;\r\n    city.description = dto.weather[0].description;\r\n    city.icon = dto.weather[0].icon;\r\n\r\n    return city;\r\n  }\r\n}\r\n\r\ninterface CityDto {\r\n  name: string,\r\n  main: {\r\n    temp: number\r\n  },\r\n  weather: Array<{\r\n    main: string,\r\n    description: string,\r\n    icon: string\r\n  }>\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/dto-converter.ts","export default class CityWheather {\r\n\r\n    private _name:string;\r\n    private _temperature:number;\r\n    private _main:string;\r\n    private _description:string;\r\n    private _icon:string;\r\n\r\n    get name():string {\r\n        return this._name;\r\n    }\r\n\r\n    set name(value:string) {\r\n        this._name = value;\r\n    }\r\n\r\n    get temperature():number {\r\n        return this._temperature;\r\n    }\r\n\r\n    set temperature(value:number) {\r\n        this._temperature = value;\r\n    }\r\n\r\n    get main():string {\r\n        return this._main;\r\n    }\r\n\r\n    set main(value:string) {\r\n        this._main = value;\r\n    }\r\n\r\n    get description():string {\r\n        return this._description;\r\n    }\r\n\r\n    set description(value:string) {\r\n        this._description = value;\r\n    }\r\n\r\n    get icon():string {\r\n        return this._icon;\r\n    }\r\n\r\n    set icon(value:string) {\r\n        this._icon = value;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/weather-dto.ts"],"sourceRoot":""}